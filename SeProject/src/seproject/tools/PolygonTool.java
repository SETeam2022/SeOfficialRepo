package seproject.tools;

import javafx.beans.property.ObjectProperty;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Polyline;
import seproject.commands.DrawShapeCommand;
import seproject.commands.Invoker;

/**
 * This class is used to model a tool which is able to draw an arbitrary polygon
 * on the screen.
 *
 */
public class PolygonTool extends DrawingTool {

    private Polyline polygon;
    private static final double DELTA = 50;

    /**
     * Create a new PolygonTool.
     *
     * @param paper is the pane on which the new polygons will be added.
     * @param strokeColorProperty is the associated ObjectProperty of Stroke
     * Interior Picker's value.
     * @param fillColorProperty is the associated ObjectProperty of Fill
     * Interior Picker's value.
     */
    public PolygonTool(Pane paper, ObjectProperty<Color> strokeColorProperty, ObjectProperty<Color> fillColorProperty) {
        super(paper, strokeColorProperty, fillColorProperty);
    }

    /**
     * This method will be called each time the mouse is pressed on the paper.
     * When the mouse is pressed and there's no partially created shape, the
     * shape is added to the pane's children and its default configuretion is
     * set, while if there's already a partially created shape, the next presses
     * will turn into vertices added to the polygon.
     *
     * @param event the event generated by the mouse being pressed on the paper
     */
    @Override
    public void onMousePressed(MouseEvent event) {
        if (polygon == null) {
            polygon = new Polyline();
            polygon.getPoints().addAll(event.getX(), event.getY());
            polygon.setStroke(this.getStrokeColorProperty().getValue());
            polygon.setFill(this.getFillColorProperty().getValue());
            polygon.setStrokeWidth(DrawingTool.widthStroke);
            Invoker.getInvoker().executeCommand(new DrawShapeCommand(polygon, paper));
        }
        polygon.getPoints().addAll(event.getX(), event.getY());
    }

    /**
     * This method will be called each time the mouse is dragged on the paper.
     * When the mouse is dragged, in order to give a visual feedback to the user
     * of the polygon being created, at each call of the method, the last added
     * point is updated.
     *
     * @param event the event generated by the mouse being dragged on the paper
     */
    @Override
    public void onMouseDragged(MouseEvent event) {
        polygon.getPoints().set(polygon.getPoints().size() - 2, event.getX());
        polygon.getPoints().set(polygon.getPoints().size() - 1, event.getY());
    }

    /**
     * This method will be called each time the mouse is released. When the
     * mouse is released, first a method is called to check if the point in
     * which the release has happened is near the first point added by the user,
     * in other words we want to check if the user wanted to close the polygon
     * but has missed the precise coordinates due to an error of the mouse
     * movement. If this check is affermative, then the coordinates of the last
     * point are set equal to the coordinates of the first one, otherwise it
     * means that the polygon has not been finished yet and we simply repalace
     * the coordinates of the last point with the ones of the event.
     *
     * @param event the event generated by the mouse being released
     */
    @Override
    public void onMouseReleased(MouseEvent event) {
        if (isNearStart(polygon.getPoints().get(0), polygon.getPoints().get(1), event.getX(), event.getY())) {
            polygon.getPoints().set(polygon.getPoints().size() - 2, polygon.getPoints().get(0));
            polygon.getPoints().set(polygon.getPoints().size() - 1, polygon.getPoints().get(1));
            polygon = null;
        } else {
            polygon.getPoints().set(polygon.getPoints().size() - 2, event.getX());
            polygon.getPoints().set(polygon.getPoints().size() - 1, event.getY());
        }
    }
    
    /* Check if the last polygon before changing tool has been completed */
    @Override    
    public void deselect() {
        
        if (polygon == null) return; 
        
        double startX = polygon.getPoints().get(0), startY = polygon.getPoints().get(1),
               endX = polygon.getPoints().get(polygon.getPoints().size()-2), endY = polygon.getPoints().get(polygon.getPoints().size()-1);
        if (!(startX == endX && startY == endY)){
            polygon.getPoints().addAll(startX, startY);
        }
        
    }
    

    /**
     * This is a utility method which, given the start and end coordinates, and
     * a fixed DELTA, checks whether the two points can be considered the same
     * in relation to the tolerance bounds.
     *
     * @param xStart
     * @param yStart
     * @param x
     * @param y
     * @return boolean
     */
    private boolean isNearStart(double xStart, double yStart, double x, double y) {
        return Math.abs(Math.abs(x) - Math.abs(xStart)) < DELTA && Math.abs(Math.abs(y) - Math.abs(yStart)) < DELTA;
    }

}
